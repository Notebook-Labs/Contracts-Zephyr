// SPDX-License-Identifier: GPL-3.0-only
pragma solidity ^0.8.18;

import "./ProverFee.sol";
import "./dep/ReentrancyGuard.sol";
import "./Orderbook.sol";
import "./DNSKeys.sol";
import "./interfaces/IGoogleVerifier.sol";
import "./interfaces/IOrderbookVerifier.sol";

/**
 * HIGH LEVEL COMMENTS:
 * This contract is the equivalent of Verifier but for Google Pay. The core differences are that the seller commits to a
 * transactionID per claim (and potentially multiple). When they commit to the Transaction ID, they will request the buyer
 * with that ID. It is up to the buyer to verify that ID and check that the amount is sufficient. The transaction ID is 
 * also revealed in the proof of payment but neither the VenmoID nor the packed ctrs are. Hence the sell order and claim 
 * counters are instead stored in a mapping of transaction ID to sell order index and claim index. The function commitTxID
 * ensures that only the seller can commit to a transaction ID and that the transaction ID cannot be overwritten.
 */
contract googleVerifier is IGoogleVerifier, ReentrancyGuard {

    /**
     * @dev Maps the address of a prover to the address of a contract used to calculate fees for proofs generated by 
     * that prover
     */
    mapping(address => address) public proverFeeContracts;

    /**
     * @dev Each index contains a sellOrderKey. 'Counters' are commited to in the proof, and each counter is used to
     * index the array to get the sellOrderKey for a particular proof/google pay transaction. There can be multiple counters
     * per sellOrderKey but once a sellOrderKey is pushed to the array, the sellOrderKey at that particular index can't
     * be changed.
     */
    bytes32[] public sellOrderCtrs; 

    /** 
     * @dev Struct used to show if a proof was verified and who was the prover. Maps a hash of the nullifier of an email
     * (a unique identifier per google pay transaction), a sell order index, and a claim index to a struct showing who the prover 
     * was and if the proof was verified.
     */
    mapping(bytes32 => Verified) public verifiedProofs; 

    /**
     * Maps a transaction ID to the corresponding sell_order_ctr and claim index.
     */
    mapping(uint96 => Counters) public txIDs;


    Orderbook public immutable orderbook;
    DNSKeys public immutable dns;
    Groth16Verifier public immutable zkVerifier;

    /**
     * @dev Max number of sellOrderCtrs that can be added to the array.
     */
    uint64 public constant COUNTER_MAX = 0xFFFFFFFFFFFFFFFF; //max uint64

    /**
     * @dev Max index that a claim can have in onrampClaims in Orderbook.sol on a particular sell order for this smart contract
     * to be able to verify its proof of payment. Done because
     */
    uint256 public constant CLAIM_MAX = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; //2^192-1


    constructor (address _orderbook, address _dns, address _zkVerifier) {
        orderbook = Orderbook(_orderbook);
        dns = DNSKeys(_dns);
        zkVerifier = Groth16Verifier(_zkVerifier);
        addCounter(bytes32(uint256(1))); //done to ensure that a claim and counter pair is never (0,0). That way we can ensure security of commitTxID.
    }

    /**
     * @notice Called to add a sellOrderKey to the sellOrderCtrs array.
     * @dev We assume that there is only one sellOrderKey per index, however the same key can be stored in multiple indices
     * of the array. 
     */
    function addCounter(bytes32 sellOrderKey) public nonReentrant {
        uint64 length = uint64(sellOrderCtrs.length);

        require(length < COUNTER_MAX, "3");
        sellOrderCtrs.push(sellOrderKey);
        
        emit SellOrderCtr(sellOrderKey, length);
    }  

    /**
     * @notice Called by the seller to commit to a transaction ID for a particular sell order and claim. This function
     * ensures that the seller cannot overwrite a transaction ID that has already been committed to.
     * @dev The seller commits to a transaction ID for a particular sell order and claim. This function ensures that the
     * seller cannot overwrite a transaction ID that has already been committed to. The seller must commit to the transaction
     * ID before the buyer can google pay them. The seller must also commit to the transaction ID before the buyer can
     * verify their proof of payment.
     * //explain the indexing incrementing
     */
    function commitTxID(IOrderbook.SellOrder calldata sellOrder, uint96 txID, uint64 sell_order_ctr, uint192 claim_index) external nonReentrant {
        //commit TxID
        require(msg.sender == sellOrder.seller, "1");

        bytes32 sellOrderKey = getSellKey(sellOrder);
        require(sellOrderCtrs[sell_order_ctr] == sellOrderKey, "2");

        //prevent overwriting
        Counters memory curValue = txIDs[txID];
        require(curValue.sell_order_ctr == 0 && curValue.claim_index == 0); //we push to sellOrderCtrs at the constructor so that a valid counter
        //pair is never (0,0)

        //map TxID -> (sell_order_ctr, claim_id)
        txIDs[txID] = Counters(sell_order_ctr, claim_index);

        emit commitTx(txID, sell_order_ctr, claim_index);
    }


    /**
     * @notice Called to calculate the prover fee for a given proof.
     * @dev Called within unlockFunds in the orderbook.
     * @return proverFee the value of the proverFee in native token decimals.
     */
    function calculateProverFee(address token, uint96 price, uint32 amount, address prover) external view returns (uint128 proverFee) {
        address proverFeeContract = proverFeeContracts[prover];

        return IProverFee(proverFeeContract).calculateFee(token, price, amount);
    }

    /**
     * @dev Called to decode a bytes representation of a HashInputs struct.
     * @param hashInputs The bytes representation of the struct. This pointer is incremented throughout the function to
     * copy values of the bytes array into the struct that gets returned.
     */
    function decodeManually(bytes memory hashInputs) public pure returns (HashInputs memory hashStruct) {
        require(hashInputs.length == 100, "69");
        
        // temp is used as a temporary variable to store the 32 byte word that is being decoded
        bytes32 temp;
        
        // The first 32 bytes of hashInputs is the length of the byte string so is skipped over. The next 32 bytes is modHash
        assembly {
            temp := mload(add(hashInputs, 32))
        }
        hashStruct.modHash = temp;

        assembly {
            temp := mload(add(hashInputs, 64))
        }
        hashStruct.Nullifier = temp;

        /*
         * After Nullifier, the next 20 bytes are Prover.
         */
        assembly {
            temp := mload(add(hashInputs, 84)) 
        }
        hashStruct.Prover = address(uint160(uint256(temp)));

        //next 12 bytes are transactionID
        assembly {
            temp := mload(add(hashInputs, 96))
        }
        hashStruct.TransactionID = uint96(uint256(temp));

        //next 4 bytes are amount
        assembly {
            temp := mload(add(hashInputs, 100))
        }
        hashStruct.Amount = uint32(uint256(temp));

        return hashStruct;
    }


    /**
     * @notice Called to verify a proof of payment and add it to the verifiedProofs.
     * @dev Decodes the structs, verifies hashInputs with respect to pubSignals[0], and then verifies the data committed to in 
     * hashInputs. Then verifies the proof using zkVerifier.
     * @param proofData the encoding of the proofData struct for the proof of payment.
     * @param hashInputs the SHA preimage of _pubSignals[0] in proofData and an encoding of a hashInputs struct, where variables are
     * tightly packed one after each other. 
     */
    function verifyProof(bytes calldata proofData, IOrderbook.SellOrder calldata sellOrder, bytes calldata hashInputs) external nonReentrant {
        
        bytes32 sellOrderKey = getSellKey(sellOrder);
        
        ProofData memory proofStruct = abi.decode(proofData, (ProofData));

        HashInputs memory hashStruct = decodeManually(hashInputs);

        //check that hashInputs hashes to the pub signal
        require(proofStruct._pubSignals[0] == (uint256(sha256(hashInputs)) >> 3), "4");
        
        // Use the transactionID to derive which claim and sell order the transaction was for
        Counters memory counters = txIDs[hashStruct.TransactionID];
        
        {
            // Check that the sell order commited to via the transactionID is the same as the sell order that was passed in
            require(sellOrderCtrs[counters.sell_order_ctr] == sellOrderKey, "6");

            //check enough money was paid via google
            (, , uint32 amount, ) = orderbook.onrampClaims(sellOrderKey, counters.claim_index);
            require(amount <= hashStruct.Amount, "7");
        }

        {
            /**
             * Use the DNS contract to check that the commitment to  google's two DNS keys in DNS is equivalent to the
             * commitment to the keys used to sign the email in the proof.
             */ 
            require(hashStruct.modHash == dns.hashValue(), "8");
        }

        zkVerifier.verify(proofStruct._pA, proofStruct._pB, proofStruct._pC, proofStruct._pubSignals);

        //need to fetch sellOrderID and claim_index from a mapping of nullifier to those maps

        /// We assume a bijection between google pay transactions and verifiedKeys
        bytes32 verifiedKey = getVerifiedKey(hashStruct.Nullifier, counters.sell_order_ctr, uint256(counters.claim_index));

        Verified memory verifiedInfo = verifiedProofs[verifiedKey];

        /**
         * Check that the proof hasn't been invalidated. We allow the case where verifiedInfo.status == 1 for cases where
         * a buyer may want to change their prover because the previous prover had too high of a proverFee, preventing them
         * from unlocking their funds.
         */
        require(verifiedInfo.status != 2, "9"); 

        verifiedProofs[verifiedKey] = Verified(1, hashStruct.Prover); 

        emit ProofVerified(hashStruct.Nullifier, counters.sell_order_ctr, uint256(counters.claim_index), hashStruct.Prover);
    }


    /**
     * @dev Called by the orderbook to check if a proof was verified and if so, return the prover and the sellOrderKey. This
     * function also nullifies the proof to ensure that it cannot be used to unlock multiple claims. If sellOrderIndex 
     * or claimIndex are greater than the maximum supported value, then there is no way that the proof could have been 
     * whitelisted in verifyProof.
     */
    function verifyPayment(bytes32 proofNullifier, uint256 sellOrderIndex, uint256 claimIndex) external nonReentrant returns (address prover, bytes32 verifierSellKey) {
        require(msg.sender == address(orderbook), "10");

        bytes32 verifiedKey = getVerifiedKey(proofNullifier, sellOrderIndex, claimIndex);

        Verified memory verifiedInfo = verifiedProofs[verifiedKey];

        require(verifiedInfo.status == 1, "11"); 

        verifiedProofs[verifiedKey].status = 2;

        emit ProofNullified(proofNullifier, sellOrderIndex, claimIndex);

        return (verifiedInfo.prover, sellOrderCtrs[sellOrderIndex]);
    }


    /**
     * @dev Called by a prover to set the address of the contract that calculates its fees. Once this contract address is set,
     * it cannot be updated. If the prover wrongly implements the calcualteProverFee method on feeContract, the user will be 
     * unable to use the prover to unlock their funds and will have to use a different prover.
     */
    function addProverContract(address prover, address feeContract) external nonReentrant {
        require(msg.sender == prover, "12");
        require(proverFeeContracts[prover] == address(0), "13");

        proverFeeContracts[prover] = feeContract;

        emit FeeContractSet(prover, feeContract);
    }

    /**
     * @notice getSellKey - a function which returns the sellOrderKey for a sell order.
     * @dev This function is used to generate the sellOrderKey for a sell order.
     */
    function getSellKey(IOrderbook.SellOrder calldata sellOrder) public pure returns (bytes32 sellOrderKey) {
        return keccak256(abi.encodePacked(sellOrder.seller, sellOrder.price, sellOrder.token, sellOrder.verifyContract, sellOrder.sybilContract));
    }

    /**
     * @dev Function to derive the verified key based off of the nullifier, sell order index, and claim index. Used to index
     * a proof in verifiedProofs. There is a bijection between google pay transactions and verifiedKeys.
     */
    function getVerifiedKey(bytes32 proofNullifier, uint256 sellOrderIndex, uint256 claimIndex) public pure returns (bytes32 verifiedKey) {
        return keccak256(abi.encodePacked(proofNullifier, sellOrderIndex, claimIndex));
    }

    /**
     * @dev View function to see if a proof has been verified.
     */
    function checkProof(bytes32 proofNullifier, uint256 sellOrderIndex, uint256 claimIndex) external view returns (uint32 status, address prover) {
        Verified memory verifiedInfo = verifiedProofs[getVerifiedKey(proofNullifier, sellOrderIndex, claimIndex)];
        return (verifiedInfo.status, verifiedInfo.prover);
    }

}


/**
 * @title Groth16Verifier
 * @notice FLAG this is a placeholder for the actual gorth16 verifier because the google pay circuits are yet to be productionized.
 */
contract Groth16Verifier {

    using Pairing for *;

    struct VerifyingKey {
        Pairing.G1Point alpha1;
        Pairing.G2Point beta2;
        Pairing.G2Point gamma2;
        Pairing.G2Point delta2;
        Pairing.G1Point[] IC;
    }

    struct Proof {
        Pairing.G1Point A;
        Pairing.G2Point B;
        Pairing.G1Point C;
    }

    /** 
     * @return vk the function returns the verifying key
     */
    function verifyingKey() internal pure returns (VerifyingKey memory vk) {
        vk.alpha1 = Pairing.G1Point(
            20491192805390485299153009773594534940189261866228447918068658471970481763042,
            9383485363053290200918347156157836566562967994039712273449902621266178545958
        );

        vk.beta2 = Pairing.G2Point(
            [
                4252822878758300859123897981450591353533073413197771768651442665752259397132,
                6375614351688725206403948262868962793625744043794305715222011528459656738731
            ],
            [
                21847035105528745403288232691147584728191162732299865338377159692350059136679,
                10505242626370262277552901082094356697409835680220590971873171140371331206856
            ]
        );
        vk.gamma2 = Pairing.G2Point(
            [
                11559732032986387107991004021392285783925812861821192530917403151452391805634,
                10857046999023057135944570762232829481370756359578518086990519993285655852781
            ],
            [
                4082367875863433681332203403145435568316851327593401208105741076214120093531,
                8495653923123431417604973247489272438418190587263600148770280649306958101930
            ]
        );
        vk.delta2 = Pairing.G2Point(
            [
                20345596193300465479284816185657941238910957461397500408804604727282674136629,
                4649505169700876117602096096679586448281846939758549915803577054643296943975
            ],
            [
                666962389731238466982073226312089857214077867359232822275488409742749677272,
                2200021173454956338322204539628004800591680288507334250229049389939086649079
            ]
        );
        vk.IC = new Pairing.G1Point[](2);

        vk.IC[0] = Pairing.G1Point(
            15820712515044762870301957854896582884082749511861351978679935817553613989866,
            13158387935381722059055150960850092355797221738430001016111471265216695104301
        );

        vk.IC[1] = Pairing.G1Point(
            12040926730376380246884161280927459364502385470470977566350736185568807107462,
            3269939990395448145454482191108467857425366115825655742306420173145029332306
        );
    }

    /** 
     * @notice This function verifies the proof with a single input signal
     * @dev This function will revert if the proof is false
     */
    function verify(uint[2] calldata pointA, uint[2][2] calldata pointB, uint[2] calldata pointC, uint[1] calldata input) public view {

        // Validate the public signal
        uint256 snarkScalarField = 21888242871839275222246405745257275088548364400416034343698204186575808495617;
        require(input[0] < snarkScalarField, "scalar too large");

        VerifyingKey memory vk = verifyingKey();

        // Compute IC0 + sIC1
        Pairing.G1Point memory vk_x = Pairing.addition(vk.IC[0], Pairing.scalarMul(vk.IC[1], input[0]));

        // Verify the pairing
        Pairing.pairing(Pairing.negate(Pairing.G1Point(pointA[0], pointA[1])), Pairing.G2Point([pointB[0][0], pointB[0][1]],[pointB[1][0], pointB[1][1]]), vk.alpha1, vk.beta2, vk_x, vk.gamma2, Pairing.G1Point(pointC[0], pointC[1]), vk.delta2);
    }
}

// code is inspired but modified from Christian Reitwiessner
library Pairing {
    struct G1Point {
        uint256 X;
        uint256 Y;
    }

    struct G2Point {
        uint256[2] X;
        uint256[2] Y;
    }

    /** 
     * @notice This function is used to negate a point in G1
     * @return r the negation of p, i.e. p.addition(p.negate()) should be zero.
     */
    function negate(G1Point memory p) internal pure returns (G1Point memory r) {
        // The prime q in the base field F_q for G1
        uint256 q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;
        if (p.X == 0 && p.Y == 0) {
            return G1Point(0, 0);
        }
        return G1Point(p.X, q - (p.Y % q));
    }
    
    /** 
     * @notice This function is a wrapper for the ecc addition precompile
     * @return r the sum of two points of G1
     */
    function addition(G1Point memory p1, G1Point memory p2) internal view returns (G1Point memory r) {

        // Pack the points into one input array
        uint256[4] memory input;
        input[0] = p1.X;
        input[1] = p1.Y;
        input[2] = p2.X;
        input[3] = p2.Y;
        bool success;
        
        // Call the precompile
        // Modified the call to padd in the exact lengths
        // The static call takes 4 inputs of 32 bytes and returns two 32 bytes outputs corresponding to an elliptic curve point
        assembly {
            success := staticcall(sub(gas(), 2000), 6, input, 0x80, r, 0x40)
        }
        require(success, "pairing-add-failed");
    }

    /** 
     * @notice This function is a wrapper for the ecc scalar multiply precompile
     * @return r the scalar multiplication of a point in G1
     */
    function scalarMul(G1Point memory p, uint256 s) internal view returns (G1Point memory r) {

        // Pack the points into one input array
        uint256[3] memory input;
        input[0] = p.X;
        input[1] = p.Y;
        input[2] = s;
        bool success;

        // Call the precompile
        // Modified the call to padd in the exact lengths
        // The static call takes 3 inputs of 32 bytes and returns two 32 bytes outputs corresponding to an elliptic curve point
        assembly {
            success := staticcall(sub(gas(), 2000), 7, input, 0x60, r, 0x40)
        }
        require(success, "pairing-mul-failed");
    }
    
    /** 
     * @notice This function is a wrapper for the ecc pairing precompile
     * @dev This function will revert if the pairing check in unsuccesful
     */
    function pairing(G1Point memory negA, G2Point memory pointB, G1Point memory alpha, G2Point memory beta, G1Point memory vk, G2Point memory gamma, G1Point memory pointC, G2Point memory delta) internal view {

        // pack the inputs
        uint256[24] memory input;

        // points for the first pairing
        input[0] = negA.X;
        input[1] = negA.Y;
        input[2] = pointB.X[0];
        input[3] = pointB.X[1];
        input[4] = pointB.Y[0];
        input[5] = pointB.Y[1];

        // points for the second pairing
        input[6] = alpha.X;
        input[7] = alpha.Y;
        input[8] = beta.X[0];
        input[9] = beta.X[1];
        input[10] = beta.Y[0];
        input[11] = beta.Y[1];

        // points for the third pairing
        input[12] = vk.X;
        input[13] = vk.Y;
        input[14] = gamma.X[0];
        input[15] = gamma.X[1];
        input[16] = gamma.Y[0];
        input[17] = gamma.Y[1];

        // points for the fourth pairing
        input[18] = pointC.X;
        input[19] = pointC.Y;
        input[20] = delta.X[0];
        input[21] = delta.X[1];
        input[22] = delta.Y[0];
        input[23] = delta.Y[1];

        uint256[1] memory out; 
        bool success;
        
        // Call the precompile
        // Modified the call to padd in the exact lengths
        // The static call takes a multiple of 6 inputs of 32 bytes and returns an output corresponding to a boolean
        // We provide 0x300 = 768 bytes of memory which corresponds to the 4 G1 points and 4 G2 points used to check the pairing equation
        assembly {
            success := staticcall(sub(gas(), 2000), 8, input, 0x300, out, 0x20)
        }
        require(success, "pairing-opcode-failed");
        require(out[0] != 0, "pairing-check-failed");
        
    }
}

