// SPDX-License-Identifier: GPL-3.0-only
pragma solidity ^0.8.18;

import "./ProverFee.sol";
import "./dep/ReentrancyGuard.sol";
import "./Orderbook.sol";
import "./DNSKeys.sol";
import "./interfaces/ICashVerifier.sol";
import "./interfaces/IOrderbookVerifier.sol";

/**
 * @title Verifier
 * @notice Verifier contract which stores commitments to the seller's cashtag and verifies proofs of payment.
 * @dev The contract SingleOutputVerifier performs the actual elliptic curve operations to verify the proof. Verifier stores
 * the commitments to the seller's cashtag and verifies additional data about the Cash App transaction which gets commited 
 * to in pubSignals[0].
 */
contract Verifier is ICashVerifier, ReentrancyGuard {

    /**
     * @dev Maps the address of a prover to the address of a contract used to calculate fees for proofs generated by 
     * that prover
     */
    mapping(address => address) public proverFeeContracts;

    /**
     * @dev Maps the address of a seller to a salted poseidon hash of their cashtag. Key value pairs are immutable 
     * once set.
     */
    mapping(address => bytes32) public cashtagHashes; 
   

    /**
     * @dev Each index contains a sellOrderKey. 'Counters' are commited to in the proof, and each counter is used to
     * index the array to get the sellOrderKey for a particular proof/Cash App transaction. There can be multiple counters
     * per sellOrderKey but once a sellOrderKey is pushed to the array, the sellOrderKey at that particular index can't
     * be changed.
     */
    bytes32[] public sellOrderCtrs; 


    /**
     * @dev This maps failed transactions to the DNS key hash used to verify the email. Including the DNS key hash means that 
     * a user cannot re-use a failed transaction to invalidate a payment (even though for this to happen it would mean that 
     * transaction IDs are not globally unique).
     */
    mapping(uint64 => bytes32) public failedTransactions;

    /** 
     * @dev Struct used to show if a proof was verified and who was the prover. Maps a hash of the nullifier of an email
     * (a unique identifier per Cash App transaction), a sell order index, and a claim index to a struct showing who the prover 
     * was, the transaction identifier, a timestamp, and if the proof was verified.
     */
    mapping(bytes32 => Verified) public verifiedProofs; 

    /** 
     * @notice waitTime - the amount of time in seconds that a buyer has to wait before a payment is confirmed. 
     * @dev This ensures that if a payment fails, the seller can invalidate the proof since the buyer will get refunded on Cash App
     */
    uint32 public immutable waitTime; // 900 seconds = 15 minutes


    Orderbook public immutable orderbook;
    DNSKeys public immutable dns;
    MainGroth16Verifier public immutable zkVerifier;
    FailGroth16Verifier public immutable failVerifier;

    /**
     * @dev Max number of sellOrderCtrs that can be added to the array. This is to allow sellOrderKeys to be referenced
     * by a 10 digit decimal number in the Cash App message.
     */
    uint64 public constant COUNTER_MAX = 10**10;

    /**
     * @dev Max index that a claim can have in onrampClaims in Orderbook.sol on a particular sell order for this smart contract
     * to be able to verify its proof of payment. This allows the claim to be referenced by a 6 digit decimal number in the Cash App
     * message. If a user's claim index is greater than this, they will be unable to unlock their funds and so should check the 
     * index they will receive before they place their claim.
     */
    uint64 public constant CLAIM_MAX = 10**6;


    constructor (address _orderbook, address _dns, address _zkVerifier, address _failVerifier, uint32 _waitTime) {
        orderbook = Orderbook(_orderbook);
        dns = DNSKeys(_dns);
        zkVerifier = MainGroth16Verifier(_zkVerifier);
        failVerifier = FailGroth16Verifier(_failVerifier);
        waitTime = _waitTime;
    }

    /**
     * @notice Called by the seller to commit to their cashtag. 
     * @dev Proofs of payments to a given seller are verified against this commitment.
     */
    function onboardSeller(address seller, bytes32 cashtagHash) external nonReentrant {
        ///FLAG: need to allow tx.origin so that the seller can use an interface to place an order in a single transaction.
        require(tx.origin == seller || msg.sender == seller, "1"); 

        //Ensure hash wasn't set before
        require(cashtagHash != 0 && cashtagHashes[seller] == 0, "2");

        cashtagHashes[seller] = cashtagHash;

        emit OnboardSeller(seller, cashtagHash);
    }

    //counter is per sell-order so uses sell order key
    /**
     * @notice Called to add a sellOrderKey to the sellOrderCtrs array.
     * @dev We assume that there is only one sellOrderKey per index, however the same key can be stored in multiple indices
     * of the array. 
     */
    function addCounter(bytes32 sellOrderKey) external nonReentrant {
        uint64 length = uint64(sellOrderCtrs.length);

        require(length < COUNTER_MAX, "3");
        sellOrderCtrs.push(sellOrderKey);
        
        emit SellOrderCtr(sellOrderKey, length);
    }  

    /**
     * @notice Called to calculate the prover fee for a given proof.
     * @dev Called within unlockFunds in the orderbook.
     * @return proverFee the value of the proverFee in native token decimals.
     */
    function calculateProverFee(address token, uint96 price, uint32 amount, address prover) external view returns (uint128 proverFee) {
        address proverFeeContract = proverFeeContracts[prover];

        return IProverFee(proverFeeContract).calculateFee(token, price, amount);
    }

    /**
     * @dev Called to decode a bytes representation of a HashInputs struct.
     * @param hashInputs The bytes representation of the struct. This pointer is incremented throughout the function to
     * copy values of the bytes array into the struct that gets returned.
     */
    function decodeManually(bytes memory hashInputs) public pure returns (HashInputs memory hashStruct) {
        require(hashInputs.length == 136, "69");
        
        // temp is used as a temporary variable to store the 32 byte word that is being decoded
        bytes32 temp;
        
        // The first 32 bytes of hashInputs is the length of the byte string so is skipped over. The next 32 bytes is modHash
        assembly {
            temp := mload(add(hashInputs, 32))
        }
        hashStruct.modHash = temp;

        // After modHash, the next 32 bytes are cashtagHash which are again copied into the struct (bytes at indices 64-95).
        assembly {
            temp := mload(add(hashInputs, 64))
        }
        hashStruct.cashtagHash = temp;

        // After cashtagHash, the next 32 bytes are Nullifier which are again copied into the struct (bytes at indices 96-127).
        assembly {
            temp := mload(add(hashInputs, 96))
        }
        hashStruct.Nullifier = temp;

        /*
         * After Nullifier, the next 20 bytes are Prover. These are the bytes at indices (128-147). Hence we copy bytes at indices
         * 116-147 into temp and then use address(uint160(uint256(temp))) to take the 20 least significant bytes of temp.
         */
        assembly {
            temp := mload(add(hashInputs, 116)) 
        }
        hashStruct.Prover = address(uint160(uint256(temp)));

        /*
         * After Prover, the next 7 bytes are ClaimKey. These are the bytes at indices (148-155). Hence we copy bytes at indices
         * 124-155 into temp and then use uint64(uint256(temp)) to take the 8 least significant bytes of temp. Then right shift by 8 bits
         */
        assembly {
            temp := mload(add(hashInputs, 124))
        }
        hashStruct.ClaimKey = uint64(uint256(temp));

        /*
         * After ClaimKey, the next 4 bytes are Amount. These are the bytes at indices (156-159). Hence we copy bytes at indices
         * 128-159 into temp and then use uint32(uint256(temp)) to take the 4 least significant bytes of temp.
         */
        assembly {
            temp := mload(add(hashInputs, 128))
        }
        hashStruct.Amount = uint32(uint256(temp));

        /*
         * After Amount, the next 8 bytes are the Identifier. These are the bytes at indices (160-167). Hence we copy bytes at indices
         * 136-167 into temp and then use uint32(uint256(temp)) to take the 4 least significant bytes of temp.
         */
        assembly {
            temp := mload(add(hashInputs, 136))
        }
        hashStruct.Identifier = uint64(uint256(temp));

        return hashStruct;
    }

    /**
     * @dev Called to decode a bytes representation of a FailHashInputs struct.
     * @param hashInputs The bytes representation of the struct. This pointer is incremented throughout the function to
     * copy values of the bytes array into the struct that gets returned.
     */
    function decodeFailManually(bytes memory hashInputs) public pure returns (FailHashInputs memory hashStruct) {
        require(hashInputs.length == 60, "69");
        
        // temp is used as a temporary variable to store the 32 byte word that is being decoded
        bytes32 temp;
        
        // The first 32 bytes of hashInputs is the length of the byte string so is skipped over. The next 32 bytes is modHash
        assembly {
            temp := mload(add(hashInputs, 32))
        }
        hashStruct.modHash = temp;

        /*
         * After the modulus hash, the next 20 bytes are Prover. These are the bytes at indices (64-83). Hence we copy bytes at indices
         * 52-83 into temp and then use address(uint160(uint256(temp))) to take the 20 least significant bytes of temp.
         */
        assembly {
            temp := mload(add(hashInputs, 52)) 
        }
        hashStruct.Prover = address(uint160(uint256(temp)));

        /*
         * After Prover, the next 8 bytes are the Identifier. These are the bytes at indices (84-91). Hence we copy bytes at indices
         * 60-91 into temp and then use uint32(uint256(temp)) to take the 4 least significant bytes of temp.
         */
        assembly {
            temp := mload(add(hashInputs, 60))
        }
        hashStruct.Identifier = uint64(uint256(temp));

        return hashStruct;
    }


    /**
     * @notice Called to verify a proof of payment and add it to the verifiedProofs.
     * @dev Decodes the structs, verifies hashInputs with respect to pubSignals[0], and then verifies the data committed to in 
     * hashInputs. Then verifies the proof using zkVerifier.
     * @param proofData the encoding of the proofData struct for the proof of payment.
     * @param hashInputs the SHA preimage of _pubSignals[0] in proofData and an encoding of a hashInputs struct, where variables are
     * tightly packed one after each other. 
     */
    function verifyProof(bytes calldata proofData, IOrderbook.SellOrder calldata sellOrder, bytes calldata hashInputs) external nonReentrant {
        
        bytes32 sellOrderKey = getSellKey(sellOrder);
        
        ProofData memory proofStruct = abi.decode(proofData, (ProofData));

        HashInputs memory hashStruct = decodeManually(hashInputs);

        //check that hashInputs hashes to the pub signal
        require(proofStruct._pubSignals[0] == (uint256(sha256(hashInputs)) >> 3), "4");
        
        {
            /**
             * The commitment to the cashtagHash is a poseidon hash of 2 field elements, one is the ascii representation of the 
             * seller's cashtag packed into a single field element and the other is a salt. This commitment is intended to be
             * perfectly binding.
             */
            require(hashStruct.cashtagHash == cashtagHashes[sellOrder.seller], "5");
        }

        // Use the cash app message to derive the sellOrderId and claimId
        (uint64 sellOrderId, uint256 claimId) = unpackClaimKey(hashStruct.ClaimKey);
        
        {
            // Verify that the buyer, when sending the Cash App, committed to sellOrderKey and thus SellOrder
            require(sellOrderCtrs[sellOrderId] == sellOrderKey, "6");

            //check enough money was sent
            (, , uint32 amount, ) = orderbook.onrampClaims(sellOrderKey, claimId);
            require(amount <= hashStruct.Amount, "7");
        }

        {
            /**
             * Use the DNS contract to check that the commitment to  Square and Amazon's DNS keys in DNS is equivalent to the
             * commitment to the keys used to sign the email in the proof.
             */ 
            require(hashStruct.modHash == dns.hashValue(), "8");
        }

        zkVerifier.verify(proofStruct._pA, proofStruct._pB, proofStruct._pC, proofStruct._pubSignals);

        /// We assume a bijection between Cash app transactions and verifiedKeys
        bytes32 verifiedKey = getVerifiedKey(hashStruct.Nullifier, sellOrderId, claimId);

        Verified memory verifiedInfo = verifiedProofs[verifiedKey];

        /**
         * Check that the proof hasn't been invalidated. We allow the case where verifiedInfo.status == 1 for cases where
         * a buyer may want to change their prover because the previous prover had too high of a proverFee, preventing them
         * from unlocking their funds.
         */
        require(verifiedInfo.status != 2, "9"); 

        verifiedProofs[verifiedKey] = Verified(1, uint32(block.timestamp), uint56(hashStruct.Identifier), hashStruct.Prover); 

        emit ProofVerified(hashStruct.Nullifier, sellOrderId, claimId, hashStruct.Identifier, hashStruct.Prover);
    }

    /**
     * @notice Called to verify a proof of payment failed and add it to the failedTransaction mapping.
     * @dev Decodes the structs, verifies hashInputs with respect to pubSignals[0], and then verifies the data committed to in 
     * hashInputs. Then verifies the proof using zkVerifier.
     * @param proofData the encoding of the proofData struct for the proof of payment.
     * @param hashInputs the SHA preimage of _pubSignals[0] in proofData and an encoding of a hashInputs struct, where variables are
     * tightly packed one after each other. 
     */
    function verifyFailedProof(bytes calldata proofData, bytes calldata hashInputs) external nonReentrant {
        
        ProofData memory proofStruct = abi.decode(proofData, (ProofData));

        FailHashInputs memory hashStruct = decodeFailManually(hashInputs);

        //check that hashInputs hashes to the pub signal
        require(proofStruct._pubSignals[0] == (uint256(sha256(hashInputs)) >> 3), "4");

        bytes32 dnsHash = dns.hashValue();

        require(hashStruct.modHash == dnsHash, "8");

        zkVerifier.verify(proofStruct._pA, proofStruct._pB, proofStruct._pC, proofStruct._pubSignals);

        failedTransactions[hashStruct.Identifier] = dnsHash;

        emit FailProofVerified(hashStruct.Identifier, hashStruct.Prover);
    }


    /**
     * @dev Called by the orderbook to check if a proof was verified and if so, return the prover and the sellOrderKey. This
     * function also nullifies the proof to ensure that it cannot be used to unlock multiple claims.
     */
    function verifyPayment(bytes32 proofNullifier, uint256 sellOrderIndex, uint256 claimIndex) external nonReentrant returns (address prover, bytes32 verifierSellKey) {
        require(msg.sender == address(orderbook), "10");

        bytes32 verifiedKey = getVerifiedKey(proofNullifier, sellOrderIndex, claimIndex);

        Verified memory verifiedInfo = verifiedProofs[verifiedKey];

        require(verifiedInfo.status == 1, "11"); 

        // check enough time has passed for the seller to react to a payment failed email
        require(verifiedInfo.timestamp + waitTime < uint32(block.timestamp), "12");

        // check the payment didn't fail w.r.t. the current DNS
        // When the DNS is updated, there is an 8 hour delay before the verifier is online again and transaction are being sent
        // because of the timelock controller. Hence we can assume that during the processing of live orders, the DNS key is 
        // constant
        require(failedTransactions[verifiedInfo.identifier] != dns.hashValue(), "13");

        verifiedProofs[verifiedKey].status = 2;

        emit ProofNullified(proofNullifier, sellOrderIndex, claimIndex);

        return (verifiedInfo.prover, sellOrderCtrs[sellOrderIndex]);
    }


    /**
     * @dev Called by a prover to set the address of the contract that calculates its fees. Once this contract address is set,
     * it cannot be updated. If the prover wrongly implements the calcualteProverFee method on feeContract, the user will be 
     * unable to use the prover to unlock their funds and will have to use a different prover.
     */
    function addProverContract(address prover, address feeContract) external nonReentrant {
        require(msg.sender == prover, "12");
        require(proverFeeContracts[prover] == address(0), "13");

        proverFeeContracts[prover] = feeContract;

        emit FeeContractSet(prover, feeContract);
    }

    /**
     * @notice getSellKey - a function which returns the sellOrderKey for a sell order.
     * @dev This function is used to generate the sellOrderKey for a sell order.
     */
    function getSellKey(IOrderbook.SellOrder calldata sellOrder) public pure returns (bytes32 sellOrderKey) {
        return keccak256(abi.encodePacked(sellOrder.seller, sellOrder.price, sellOrder.token, sellOrder.verifyContract, sellOrder.sybilContract));
    }

    /**
     * @dev Function to derive the verified key based off of the nullifier, sell order index, and claim index. Used to index
     * a proof in verifiedProofs. There is a bijection between venmo transactions and verifiedKeys.
     */
    function getVerifiedKey(bytes32 proofNullifier, uint256 sellOrderIndex, uint256 claimIndex) public pure returns (bytes32 verifiedKey) {
        return keccak256(abi.encodePacked(proofNullifier, sellOrderIndex, claimIndex));
    }

    /**
     * @dev Function to unpack a 16 digit decimal number into a sellOrderId and claimId. 
     * @return sellOrderId The first 10 digits of claim.
     * @return claimId The last 6 digits of claim.
     */
    function unpackClaimKey(uint64 claim) public pure returns (uint64 sellOrderId, uint256 claimId) {
        sellOrderId = claim / CLAIM_MAX;
        uint64 tempClaimId = claim - sellOrderId * CLAIM_MAX;
        return (sellOrderId, uint256(tempClaimId));
    }

    /**
     * @dev View function to see if a proof has been verified.
     */
    function checkProof(bytes32 proofNullifier, uint256 sellOrderIndex, uint256 claimIndex) external view returns (uint32 status, address prover) {
        Verified memory verifiedInfo = verifiedProofs[getVerifiedKey(proofNullifier, sellOrderIndex, claimIndex)];
        return (verifiedInfo.status, verifiedInfo.prover);
    }

}

/**
 * @title MainGroth16Verifier
 * @notice MainGroth16Verifier contract verifies a groth16 proof of a cashApp sent payment with a single output.
 */
contract MainGroth16Verifier {

    using Pairing for *;

    struct VerifyingKey {
        Pairing.G1Point alpha1;
        Pairing.G2Point beta2;
        Pairing.G2Point gamma2;
        Pairing.G2Point delta2;
        Pairing.G1Point[] IC;
    }

    struct Proof {
        Pairing.G1Point A;
        Pairing.G2Point B;
        Pairing.G1Point C;
    }

    /** 
     * @return vk the function returns the verifying key
     */
    function verifyingKey() internal pure returns (VerifyingKey memory vk) {
        vk.alpha1 = Pairing.G1Point(
            20491192805390485299153009773594534940189261866228447918068658471970481763042,
            9383485363053290200918347156157836566562967994039712273449902621266178545958
        );

        vk.beta2 = Pairing.G2Point(
            [
                4252822878758300859123897981450591353533073413197771768651442665752259397132,
                6375614351688725206403948262868962793625744043794305715222011528459656738731
            ],
            [
                21847035105528745403288232691147584728191162732299865338377159692350059136679,
                10505242626370262277552901082094356697409835680220590971873171140371331206856
            ]
        );
        vk.gamma2 = Pairing.G2Point(
            [
                11559732032986387107991004021392285783925812861821192530917403151452391805634,
                10857046999023057135944570762232829481370756359578518086990519993285655852781
            ],
            [
                4082367875863433681332203403145435568316851327593401208105741076214120093531,
                8495653923123431417604973247489272438418190587263600148770280649306958101930
            ]
        );
        vk.delta2 = Pairing.G2Point(
            [
                20345596193300465479284816185657941238910957461397500408804604727282674136629,
                4649505169700876117602096096679586448281846939758549915803577054643296943975
            ],
            [
                666962389731238466982073226312089857214077867359232822275488409742749677272,
                2200021173454956338322204539628004800591680288507334250229049389939086649079
            ]
        );
        vk.IC = new Pairing.G1Point[](2);

        vk.IC[0] = Pairing.G1Point(
            15820712515044762870301957854896582884082749511861351978679935817553613989866,
            13158387935381722059055150960850092355797221738430001016111471265216695104301
        );

        vk.IC[1] = Pairing.G1Point(
            12040926730376380246884161280927459364502385470470977566350736185568807107462,
            3269939990395448145454482191108467857425366115825655742306420173145029332306
        );
    }

    /** 
     * @notice This function verifies the proof with a single input signal
     * @dev This function will revert if the proof is false
     */
    function verify(uint[2] calldata pointA, uint[2][2] calldata pointB, uint[2] calldata pointC, uint[1] calldata input) public view {

        // Validate the public signal
        uint256 snarkScalarField = 21888242871839275222246405745257275088548364400416034343698204186575808495617;
        require(input[0] < snarkScalarField, "scalar too large");

        VerifyingKey memory vk = verifyingKey();

        // Compute IC0 + sIC1
        Pairing.G1Point memory vk_x = Pairing.addition(vk.IC[0], Pairing.scalarMul(vk.IC[1], input[0]));

        // Verify the pairing
        Pairing.pairing(Pairing.negate(Pairing.G1Point(pointA[0], pointA[1])), Pairing.G2Point([pointB[0][0], pointB[0][1]],[pointB[1][0], pointB[1][1]]), vk.alpha1, vk.beta2, vk_x, vk.gamma2, Pairing.G1Point(pointC[0], pointC[1]), vk.delta2);
    }
}

// code is inspired but modified from Christian Reitwiessner
library Pairing {
    struct G1Point {
        uint256 X;
        uint256 Y;
    }

    struct G2Point {
        uint256[2] X;
        uint256[2] Y;
    }

    /** 
     * @notice This function is used to negate a point in G1
     * @return r the negation of p, i.e. p.addition(p.negate()) should be zero.
     */
    function negate(G1Point memory p) internal pure returns (G1Point memory r) {
        // The prime q in the base field F_q for G1
        uint256 q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;
        if (p.X == 0 && p.Y == 0) {
            return G1Point(0, 0);
        }
        return G1Point(p.X, q - (p.Y % q));
    }
    
    /** 
     * @notice This function is a wrapper for the ecc addition precompile
     * @return r the sum of two points of G1
     */
    function addition(G1Point memory p1, G1Point memory p2) internal view returns (G1Point memory r) {

        // Pack the points into one input array
        uint256[4] memory input;
        input[0] = p1.X;
        input[1] = p1.Y;
        input[2] = p2.X;
        input[3] = p2.Y;
        bool success;
        
        // Call the precompile
        // Modified the call to padd in the exact lengths
        // The static call takes 4 inputs of 32 bytes and returns two 32 bytes outputs corresponding to an elliptic curve point
        assembly {
            success := staticcall(sub(gas(), 2000), 6, input, 0x80, r, 0x40)
        }
        require(success, "pairing-add-failed");
    }

    /** 
     * @notice This function is a wrapper for the ecc scalar multiply precompile
     * @return r the scalar multiplication of a point in G1
     */
    function scalarMul(G1Point memory p, uint256 s) internal view returns (G1Point memory r) {

        // Pack the points into one input array
        uint256[3] memory input;
        input[0] = p.X;
        input[1] = p.Y;
        input[2] = s;
        bool success;

        // Call the precompile
        // Modified the call to padd in the exact lengths
        // The static call takes 3 inputs of 32 bytes and returns two 32 bytes outputs corresponding to an elliptic curve point
        assembly {
            success := staticcall(sub(gas(), 2000), 7, input, 0x60, r, 0x40)
        }
        require(success, "pairing-mul-failed");
    }
    
    /** 
     * @notice This function is a wrapper for the ecc pairing precompile
     * @dev This function will revert if the pairing check in unsuccesful
     */
    function pairing(G1Point memory negA, G2Point memory pointB, G1Point memory alpha, G2Point memory beta, G1Point memory vk, G2Point memory gamma, G1Point memory pointC, G2Point memory delta) internal view {

        // pack the inputs
        uint256[24] memory input;

        // points for the first pairing
        input[0] = negA.X;
        input[1] = negA.Y;
        input[2] = pointB.X[0];
        input[3] = pointB.X[1];
        input[4] = pointB.Y[0];
        input[5] = pointB.Y[1];

        // points for the second pairing
        input[6] = alpha.X;
        input[7] = alpha.Y;
        input[8] = beta.X[0];
        input[9] = beta.X[1];
        input[10] = beta.Y[0];
        input[11] = beta.Y[1];

        // points for the third pairing
        input[12] = vk.X;
        input[13] = vk.Y;
        input[14] = gamma.X[0];
        input[15] = gamma.X[1];
        input[16] = gamma.Y[0];
        input[17] = gamma.Y[1];

        // points for the fourth pairing
        input[18] = pointC.X;
        input[19] = pointC.Y;
        input[20] = delta.X[0];
        input[21] = delta.X[1];
        input[22] = delta.Y[0];
        input[23] = delta.Y[1];

        uint256[1] memory out; 
        bool success;
        
        // Call the precompile
        // Modified the call to padd in the exact lengths
        // The static call takes a multiple of 6 inputs of 32 bytes and returns an output corresponding to a boolean
        // We provide 0x300 = 768 bytes of memory which corresponds to the 4 G1 points and 4 G2 points used to check the pairing equation
        assembly {
            success := staticcall(sub(gas(), 2000), 8, input, 0x300, out, 0x20)
        }
        require(success, "pairing-opcode-failed");
        require(out[0] != 0, "pairing-check-failed");
        
    }
}

/**
 * @title FailGroth16Verifier
 * @notice FailGroth16Verifier contract verifies a groth16 proof of a cashApp sent payment with a single output.
 */
contract FailGroth16Verifier {

    using Pairing for *;

    struct VerifyingKey {
        Pairing.G1Point alpha1;
        Pairing.G2Point beta2;
        Pairing.G2Point gamma2;
        Pairing.G2Point delta2;
        Pairing.G1Point[] IC;
    }

    struct Proof {
        Pairing.G1Point A;
        Pairing.G2Point B;
        Pairing.G1Point C;
    }

    /** 
     * @return vk the function returns the verifying key
     */
    function verifyingKey() internal pure returns (VerifyingKey memory vk) {
        vk.alpha1 = Pairing.G1Point(
            20491192805390485299153009773594534940189261866228447918068658471970481763042,
            9383485363053290200918347156157836566562967994039712273449902621266178545958
        );

        vk.beta2 = Pairing.G2Point(
            [
                4252822878758300859123897981450591353533073413197771768651442665752259397132,
                6375614351688725206403948262868962793625744043794305715222011528459656738731
            ],
            [
                21847035105528745403288232691147584728191162732299865338377159692350059136679,
                10505242626370262277552901082094356697409835680220590971873171140371331206856
            ]
        );
        vk.gamma2 = Pairing.G2Point(
            [
                11559732032986387107991004021392285783925812861821192530917403151452391805634,
                10857046999023057135944570762232829481370756359578518086990519993285655852781
            ],
            [
                4082367875863433681332203403145435568316851327593401208105741076214120093531,
                8495653923123431417604973247489272438418190587263600148770280649306958101930
            ]
        );
        vk.delta2 = Pairing.G2Point(
            [
                20345596193300465479284816185657941238910957461397500408804604727282674136629,
                4649505169700876117602096096679586448281846939758549915803577054643296943975
            ],
            [
                666962389731238466982073226312089857214077867359232822275488409742749677272,
                2200021173454956338322204539628004800591680288507334250229049389939086649079
            ]
        );
        vk.IC = new Pairing.G1Point[](2);

        vk.IC[0] = Pairing.G1Point(
            15820712515044762870301957854896582884082749511861351978679935817553613989866,
            13158387935381722059055150960850092355797221738430001016111471265216695104301
        );

        vk.IC[1] = Pairing.G1Point(
            12040926730376380246884161280927459364502385470470977566350736185568807107462,
            3269939990395448145454482191108467857425366115825655742306420173145029332306
        );
    }

    /** 
     * @notice This function verifies the proof with a single input signal
     * @dev This function will revert if the proof is false
     */
    function verify(uint[2] calldata pointA, uint[2][2] calldata pointB, uint[2] calldata pointC, uint[1] calldata input) public view {

        // Validate the public signal
        uint256 snarkScalarField = 21888242871839275222246405745257275088548364400416034343698204186575808495617;
        require(input[0] < snarkScalarField, "scalar too large");

        VerifyingKey memory vk = verifyingKey();

        // Compute IC0 + sIC1
        Pairing.G1Point memory vk_x = Pairing.addition(vk.IC[0], Pairing.scalarMul(vk.IC[1], input[0]));

        // Verify the pairing
        Pairing.pairing(Pairing.negate(Pairing.G1Point(pointA[0], pointA[1])), Pairing.G2Point([pointB[0][0], pointB[0][1]],[pointB[1][0], pointB[1][1]]), vk.alpha1, vk.beta2, vk_x, vk.gamma2, Pairing.G1Point(pointC[0], pointC[1]), vk.delta2);
    }
}
